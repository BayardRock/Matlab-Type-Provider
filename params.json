{"name":"F# Matlab Type Provider","tagline":"A (not yet complete) Type Provider for Matlab in the spirit of the R Type Provider","body":"### What to expect\r\n\r\nThe goal of this project is to provide a smooth and efficient framework for F#-Matlab interactions.  The goals for 1.0 include support for most Matlab functions and types in as well typed a manner as possible.\r\n\r\nA simple version of our goal is now working fairly well.  Give it a little play and let me know if you find any problems.\r\n\r\n### Current Requirements\r\n\r\n* Matlab 2013a (or earlier with [strjoin.m](http://www.mathworks.com/matlabcentral/fileexchange/31862-strjoin), tested up to 2012a)\r\n* Visual Studio 2012 (May work with other Windows F# IDEs as well, but not tested)\r\n\r\n### Current Capabilities\r\n\r\n* Access non-complex Values, Matrices and Vectors in a strongly typed fashion. \r\n* The ability to call Matlab Toolbox functions with appropriate F# values.\r\n\r\n### Getting Started\r\n\r\nAdd the following parameters to your Matlab 2013a shortcut:\r\n\r\n`matlab.exe -automation -desktop`\r\n\r\nThis will allow you to keep a Matlab session open while you connect and disconnect with Visual Studio. If you don't do this then the Matlab Provider will launch a session when it starts which will close when the Type Provider is unloaded. \r\n\r\nThen you must load the type provider.  This is done either by an assembly reference, if you're using it in your project, or by specifying it like so in your F# .fsx script:\r\n\r\n`#R \"MatlabTypeProvider.dll\"`\r\n\r\n## The Simple Matlab Provider\r\n\r\nThen just access variables that were bound in Matlab before the Type Provider was loaded like so: \r\n\r\n```\r\nopen SimpleMatlabProvider\r\nlet xFromMatlab = Vars.X\r\n```\r\n\r\nYou can find supported functions inside of their Matlab toolboxes:\r\n\r\n```\r\nopen SimpleMatlabProvider\r\nlet res = Toolboxes.``matlab\\elfun``.nthroot(6.0, 2.0)\r\n```\r\n\r\nVarargin and varargout parameters are treated as arrays, and all built-in functions are treated as varargin/varargout. \r\n\r\n```\r\nopen SimpleMatlabProvider\r\nlet [| res |] = Toolboxes.``matlab\\elfun``.cos([|0.0|]) \r\n```\r\n\r\n## The Lazy Matlab Provider\r\n\r\nThe lazy provider is similar to the simple one, but only deals in handles to functions and variables by default.  This prevents a lot of extra pushing data back-and-forth from Matlab when doing complex combinations of functions.  It also allows you to select exactly how many output parameters you want.\r\n\r\n```\r\nopen LazyMatlabProvider\r\nopen FSMatlab.InterfaceTypes\r\nlet m,n = Toolboxes.``matlab\\elmat``.size([|1.0;2.0;3.0;4.0;5.0|]) |> EGT2<double,double>\r\n```\r\n\r\nHere EGT2 stands for Execute-Get-Typed with two outputs.  Because you are not being returned a variable  handle this will automatically delete the temporary result.  We also provide the E function which just executes and returns a handle:\r\n\r\n```\r\nuse x = Toolboxes.``matlab\\elfun``.nthroot(9.0, 2.0) |> E1\r\n```\r\n\r\nHere x is a handle to an variable active variable in your Matlab instance.  Note that it implements IDisposable and so when used with the __use__ keyword will automatically be deleted from Matlab when it leaves scope.  You can use it as you see fit and delete it when you're done.  \r\n\r\n```\r\nlet x_val_obj = res_var.GetUntyped() // type is obj\r\nlet x_val_typed : double = res_var.Get() // type is double\r\n```\r\n\r\n### Known Problems / Future Work\r\n\r\n* .Mex (and .Mexw64) files are not yet supported.  All accessible functions must have a corresponding .m file. \r\n* The current communication interface is COM, and I expect this puts a limit on the size of things.  I hope to be moving to the dll interface once I get things going a bit more.  In the long run I'd very much like to be able to support MacOS and Linux.\r\n* Currently any call to a Matlab function will return all of its result values, even the optional ones.  I'm currently exploring several approaches to resolving this.\r\n* Toolbox naming is a bit wonky, but allows for easy exploration. \r\n* The type provider does not currently take any static parameters.  I'd like it to support at least the ability to select the way to contact Matlab and also to execute a specified script to bind variables.\r\n* It would be ideal to be able to compose functions in F# and then have the entire call be executed in Matlab.  This may take some doing, but I believe it's completely possible. \r\n\r\n### Planned Limitations\r\n\r\n* The parameters to and the result of calls to Matlab functions will remain untyped for the foreseeable future.  As it currently stands, there seems be no way to provide types for Matlab functions without manual labeling as with TypeScript.\r\n* You can't get any information about the built in functions and so they'll be treated as varargin/varargout for the foreseeable future.","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}